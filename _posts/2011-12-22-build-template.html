---
status: publish
published: true
title: Build template
author:
  display_name: cout
  login: cout
  email: curlypaul924@gmail.com
  url: ''
author_login: cout
author_email: curlypaul924@gmail.com
wordpress_id: 58
wordpress_url: http://nonstandard-output.rubystuff.org/?p=58
date: '2011-12-22 13:37:51 -0500'
date_gmt: '2011-12-22 18:37:51 -0500'
categories:
- Uncategorized
tags: []
comments: []
---
<p>I don't like <a href="http://en.wikipedia.org/wiki/Make_(software)" title="Make (software)">make</a>.</p>
<p>The syntax is clunky, the semantics are unintuitive, it's hard to get parallel builds to work well, and there are a million ways to shoot yourself in the foot.</p>
<p>Nevertheless, I stick with it, because it's ubiquitous and it's the simplest solution for what I do.</p>
<p>A simple Makefile might look like this:</p>
<pre lang="make">
all: main

OBJS = \
  Foo.o \
  Bar.o \
  Baz.o

main: $(OBJS)
  $(CXX) $(LDFLAGS) $^ -o $@
</pre>
<p>This says <code>main</code> depends on <code>Foo.o</code>, <code>Bar.o</code>, and <code>Baz.o</code>; each of these is built using one of the builtin rules.</p>
<p>I often want some extra build flags for debugging or optimization, so I add:</p>
<pre lang="make">
CFLAGS += -ggdb
CXXFLAGS += -fno-inline
</pre>
<p>If I'm using GCC and I want automatic dependency generation, I add this:</p>
<pre lang="make">
CFLAGS += -MMD -MP
DEP_FILES = $(patsubst %.o,%.d,$(OBJS))
-include $(DEP_FILES)
</pre>
<p>Now whenever I build Foo.o from <code>Foo.cpp</code> (or <code>Foo.c</code>), g++ will generate Foo.d at the same time.  The next time I type <code>make</code>, it will read Foo.d to determine what Foo.o depends on.</p>
<p>And just in case something gets borked, I usually want a <code>clean</code> rule:</p>
<pre lang="make">
GENERATED_FILES += $(OBJS)

.PHONY: clean
clean:
  $(RM) $(GENERATED_FILES)
</pre>
<p>Now none of this is intuitive (I learned it all from trial-and-error), and there's a whole lot more that build systems need to do (building shared libraries, finding where libraries are located on a system, etc.), but this really does solve 90% of the problems I hit in small-to-medium projects.  I've even used a setup like this in a medium-large project (> 200K lines of code) with success.</p>
<p>Please, tell me why I should switch?  I despise make just as much as the next guy, but it's simple, and it <i>works</i>.</p>
